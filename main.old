

#if 0
  // Lufkin, E, and Hawley, J. 1992
      const double u_ii = 0.5*(
          fabs((u[ind1+1]-u[ind1])-(u[ind1]-u[ind1-1])) + 
          fabs((u[ind1]-u[ind1-1])-(u[ind1-1]-u[ind1-2])));
      const double v_ii = 0.5*(
          fabs((v[ind0+nx]-v[ind0])-(v[ind0]-v[ind0-nx])) + 
          fabs((v[ind0]-v[ind0-nx])-(v[ind0-nx]-v[ind0-2*nx])));
      Qxx[ind0] = -C_Q*rho[ind0]*u_i*u_ii;
      Qyy[ind0] = -C_Q*rho[ind0]*v_i*v_ii;
#endif // if 0
#if 0
      // TODO: FIx the small osciallations in momentum that occur when running the
      // sod shock problem. It seems that there is some numerical issue that
      // is causing some amount of velocity to occur. Run bottom sod and check u after
      // some hundreds of steps.
      if(P[ind0] != P[ind0-1]) {
        printf("diff: %.15e, ind %d\n", P[ind0]-P[ind0-1], ind0);
        printf("e_l: %.15e, e_r: %.15e, rho_l: %.15e, rho_r: %.15e\n", 
            P[ind0-1]/rho[ind0-1], P[ind0]/rho[ind0], rho[ind0-1], rho[ind0]);
      }
#endif // if 0

#if 0
      if(jj+mesh->x_off < mesh->global_nx/2) { //LEFT SOD
        state->rho[ii*mesh->local_nx+jj] = 1.0;
        state->e[ii*mesh->local_nx+jj] = 2.5;
      }
#endif // if 0
#if 0
      if(jj+mesh->x_off > mesh->global_nx/2) { //LEFT SOD
        state->rho[ii*mesh->local_nx+jj] = 1.0;
        state->e[ii*mesh->local_nx+jj] = 2.5;
      }
#endif // if 0

#if 0
      if(ii+mesh->y_off < mesh->global_ny/2) { //BOTTOM SOD
        state->rho[ii*mesh->local_nx+jj] = 1.0;
        state->e[ii*mesh->local_nx+jj] = 2.5;
      }
#endif // if 0

#if 0
      // BLUE HOLE TEST 
      const int m = 258;
      const int o = 10400;
      if((ii - m)*(ii - m) + (jj - m)*(jj - m) > o) {
        state->rho[ii*mesh->local_nx+jj] = 1.0;
        state->e[ii*mesh->local_nx+jj] = 2.5;
      }
#endif // if 0

#if 0
  // TODO: FIX THIS - CURRENTLY ASSUMING THAT THERE IS NO VELOCITY

  // Calculate the zone edge centered density
  const double rho_edge_x = 
    (state->rho[ind0]*mesh->celldx[jj]*mesh->celldy[ii] + 
     state->rho[ind0-1]*mesh->celldx[jj - 1]*mesh->celldy[ii]) / 
    (2.0*mesh->edgedx[jj]*mesh->celldy[ii]);
  const double rho_edge_y = 
    (state->rho[ind0]*mesh->celldx[jj]*mesh->celldy[ii] + 
     state->rho[ind0-mesh->local_nx]*mesh->celldx[jj]*mesh->celldy[ii - 1]) / 
    (2.0*mesh->celldx[jj]*mesh->edgedy[ii]);

  // Find the velocities from the momenta and edge centered mass densities
  state->rho_u[ind1] = state->u[ind1] * rho_edge_x;
  state->rho_v[ind0] = state->v[ind0] * rho_edge_y;
#endif // if 0
#if 0
/// TODO: What happens about the slopes defined on the halo regions, 
// is it OK that they are simply set to 0???
#pragma omp parallel for
for(int ii = PAD; ii < ny-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < nx-PAD; ++jj) {
    // Calculate the maximum and minimum neighbouring density
    const double rho_x_max = max(rho[ind0-1], max(rho[ind0], rho[ind0+1]));
    const double rho_x_min = min(rho[ind0-1], min(rho[ind0], rho[ind0+1]));
    const double rho_y_max = max(rho[ind0-nx], max(rho[ind0], rho[ind0+nx]));
    const double rho_y_min = min(rho[ind0-nx], min(rho[ind0], rho[ind0+nx]));

    // Construct absolute value of slope S_L or S_R
    const double s1_x = 
      min(rho_x_max - rho[ind0], rho[ind0] - rho_x_min) / (celldx[jj] / 2.0);
    const double s1_y = 
      min(rho_y_max - rho[ind0], rho[ind0] - rho_y_min) / (celldy[ii] / 2.0);

    // Calculate the density interpolated from the zone center to zone boundary
    const double rho_edge_l = 
      (celldx[jj]*rho[ind0-1] + celldx[jj - 1]*rho[ind0])/(celldx[jj] + celldx[jj - 1]);
    const double rho_edge_r = 
      (celldx[jj + 1]*rho[ind0] + celldx[jj]*rho[ind0+1])/(celldx[jj + 1] + celldx[jj]);
    const double rho_edge_d = 
      (celldy[ii]*rho[ind0-nx] + celldy[ii - 1]*rho[ind0])/(celldy[ii] + celldy[ii - 1]);
    const double rho_edge_u = 
      (celldy[ii + 1]*rho[ind0] + celldy[ii]*rho[ind0+nx])/(celldy[ii + 1] + celldy[ii]);

    // Construct the slope
    const double s2_x = (rho_edge_r - rho_edge_l) / celldx[jj];
    const double s2_y = (rho_edge_u - rho_edge_d) / celldy[ii];

    // Define the zone centered slope (culling 0's)
    slope_x[ind0] = (s2_x != 0.0) ? (s2_x / fabs(s2_x))*min(fabs(s2_x), s1_x) : 0.0;
    slope_y[ind0] = (s2_y != 0.0) ? (s2_y / fabs(s2_y))*min(fabs(s2_y), s1_y) : 0.0;
  }
}

// Calculate the zone edge centered energies, and flux
#pragma omp parallel for
for(int ii = PAD; ii < ny-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < (nx+1)-PAD; ++jj) {
    // Calculate the interpolated densities
    const double edge_rho_x = (u[ind1] >= 0.0)
      ? rho[ind0-1] + 0.5*slope_x[ind0-1]*(celldx[jj-1] - u[ind1]*dt_h)
      : rho[ind0] - 0.5*slope_x[ind0]*(celldx[jj] + u[ind1]*dt_h);
    F_x[ind1] = edge_rho_x*u[ind1]; 
  }
}

// Calculate the zone edge centered energies, and flux
#pragma omp parallel for
for(int ii = PAD; ii < (ny+1)-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < nx-PAD; ++jj) {
    // Calculate the interpolated densities
    const double edge_rho_y = (v[ind0] >= 0.0)
      ? rho[ind0-nx] + 0.5*slope_y[ind0-nx]*(celldy[ii-1] - v[ind0]*dt_h)
      : rho[ind0] - 0.5*slope_y[ind0]*(celldy[ii] + v[ind0]*dt_h);
    F_y[ind0] = edge_rho_y*v[ind0]; 
  }
}
#endif // if 0

#if 0
#pragma omp parallel for
for(int ii = PAD; ii < (ny+1)-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < (nx+1)-PAD; ++jj) {
    // Calculate the zone edge centered density
    const double rho_edge_x = 
      (rho[ind0]*celldx[jj]*celldy[ii] + rho[ind0-1]*celldx[jj - 1]*celldy[ii]) / 
      (2.0*edgedx[jj]*celldy[ii]);
    const double rho_edge_y = 
      (rho[ind0]*celldy[ii]*celldx[jj] + rho[ind0-nx]*celldy[ii - 1]*celldx[jj]) / 
      (2.0*edgedx[jj]*celldy[ii]);
    u[ind1] = (rho_edge_x == 0.0) ? 0.0 : rho_u[ind1] / rho_edge_x;
    v[ind0] = (rho_edge_y == 0.0) ? 0.0 : rho_v[ind0] / rho_edge_y;
  }
}

handle_boundary(nx+1, ny, neighbours, u, INVERT_X);
handle_boundary(nx, ny+1, neighbours, v, INVERT_Y);
#endif // if 0



#if 0
// Batches the halos up into buffers, communicates and then unwraps them
void communicate_halos(
    const int nx, const int ny, Mesh* mesh, double* rho, double* rho_u, 
    double* rho_v, double* e)
{
  int nmessages = 0;
  MPI_Request out_req[NNEIGHBOURS];
  MPI_Request in_req[NNEIGHBOURS];

  // TODO: Currently overestimating the amount of data to send
  const int message_length_x = (nx+1)*PAD*NVARS_TO_COMM; 
  const int message_length_y = (ny+1)*PAD*NVARS_TO_COMM;

  if(mesh->neighbours[SOUTH] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < nx; ++jj) {
        const int out_index = dd*nx+jj;
        mesh->south_buffer_out[(RHO_OFF*(nx+1)*PAD)+out_index]   = rho  [(PAD+dd)*nx+jj];
        mesh->south_buffer_out[(E_OFF*(nx+1)*PAD)+out_index]     = e    [(PAD+dd)*nx+jj];
        mesh->south_buffer_out[(RHO_V_OFF*(nx+1)*PAD)+out_index] = rho_v[(PAD+dd)*nx+jj];
      }
    }

#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < (nx+1); ++jj) {
        const int out_index = dd*(nx+1)+jj;
        mesh->south_buffer_out[(RHO_U_OFF*(nx+1)*PAD)+out_index] = rho_u[(PAD+dd)*(nx+1)+jj];
      }
    }

    MPI_Isend(mesh->south_buffer_out, message_length_x, MPI_DOUBLE, 
        mesh->neighbours[SOUTH], 0, MPI_COMM_WORLD, &out_req[SOUTH]);
    MPI_Irecv(mesh->south_buffer_in, message_length_x, MPI_DOUBLE,
        mesh->neighbours[SOUTH], 1, MPI_COMM_WORLD, &in_req[nmessages++]);
  }

  if(mesh->neighbours[NORTH] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < nx; ++jj) {
        const int out_index = dd*nx+jj;
        mesh->north_buffer_out[(RHO_OFF*(nx+1)*PAD)+out_index]   = rho  [(ny-2*PAD+dd)*nx+jj];
        mesh->north_buffer_out[(E_OFF*(nx+1)*PAD)+out_index]     = e    [(ny-2*PAD+dd)*nx+jj];
        mesh->north_buffer_out[(RHO_V_OFF*(nx+1)*PAD)+out_index] = rho_v[((ny+1)-2*PAD+dd)*nx+jj];
      }
    }
#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < (nx+1); ++jj) {
        const int out_index = dd*(nx+1)+jj;
        mesh->north_buffer_out[(RHO_U_OFF*(nx+1)*PAD)+out_index] = rho_u[(ny-2*PAD+dd)*(nx+1)+jj];
      }
    }

    MPI_Isend(mesh->north_buffer_out, message_length_x, MPI_DOUBLE, 
        mesh->neighbours[NORTH], 1, MPI_COMM_WORLD, &out_req[NORTH]);
    MPI_Irecv(mesh->north_buffer_in, message_length_x, MPI_DOUBLE,
        mesh->neighbours[NORTH], 0, MPI_COMM_WORLD, &in_req[nmessages++]);
  }

  if(mesh->neighbours[EAST] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int ii = 0; ii < ny; ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int out_index = ii*PAD+dd;
        mesh->east_buffer_out[out_index+(RHO_OFF*ny*PAD)]   = rho  [(ii*nx)+(nx-2*PAD+dd)];
        mesh->east_buffer_out[out_index+(E_OFF*ny*PAD)]     = e    [(ii*nx)+(nx-2*PAD+dd)];
        mesh->east_buffer_out[out_index+(RHO_U_OFF*ny*PAD)] = rho_u[(ii*(nx+1))+((nx+1)-2*PAD+dd)];
      }
    }
    for(int ii = 0; ii < (ny+1); ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int out_index = ii*PAD+dd;
        mesh->east_buffer_out[out_index+(RHO_V_OFF*ny*PAD)] = rho_v[(ii*nx)+(nx-2*PAD+dd)];
      }
    }

    MPI_Isend(mesh->east_buffer_out, message_length_y, MPI_DOUBLE, 
        mesh->neighbours[EAST], 2, MPI_COMM_WORLD, &out_req[EAST]);
    MPI_Irecv(mesh->east_buffer_in, message_length_y, MPI_DOUBLE,
        mesh->neighbours[EAST], 3, MPI_COMM_WORLD, &in_req[nmessages++]);
  }

  if(mesh->neighbours[WEST] != EDGE) {
    for(int ii = 0; ii < ny; ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int out_index = ii*PAD+dd;
        mesh->west_buffer_out[out_index+(RHO_OFF*ny*PAD)]   = rho  [(ii*nx)+(PAD+dd)];
        mesh->west_buffer_out[out_index+(E_OFF*ny*PAD)]     = e    [(ii*nx)+(PAD+dd)];
        mesh->west_buffer_out[out_index+(RHO_U_OFF*ny*PAD)] = rho_u[(ii*(nx+1))+(PAD+dd)];
      }
    }
    for(int ii = 0; ii < (ny+1); ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int out_index = ii*PAD+dd;
        mesh->west_buffer_out[out_index+(RHO_V_OFF*ny*PAD)] = rho_v[(ii*nx)+(PAD+dd)];
      }
    }

    MPI_Isend(mesh->west_buffer_out, message_length_y, MPI_DOUBLE,
        mesh->neighbours[WEST], 3, MPI_COMM_WORLD, &out_req[WEST]);
    MPI_Irecv(mesh->west_buffer_in, message_length_y, MPI_DOUBLE, 
        mesh->neighbours[WEST], 2, MPI_COMM_WORLD, &in_req[nmessages++]);
  }

  MPI_Waitall(nmessages, in_req, MPI_STATUSES_IGNORE);

  if(mesh->neighbours[NORTH] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < nx; ++jj) {
        const int in_index = dd*nx+jj;
        rho  [(ny-PAD+dd)*nx+jj] = mesh->north_buffer_in[(RHO_OFF*(nx+1)*PAD)+in_index];
        e    [(ny-PAD+dd)*nx+jj] = mesh->north_buffer_in[(E_OFF*(nx+1)*PAD)+in_index];
        rho_v[((ny+1)-PAD+dd)*nx+jj] = mesh->north_buffer_in[(RHO_V_OFF*(nx+1)*PAD)+in_index];
      }
    }
#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < (nx+1); ++jj) {
        const int in_index = dd*(nx+1)+jj;
        rho_u[(ny-PAD+dd)*(nx+1)+jj] = mesh->north_buffer_in[(RHO_U_OFF*(nx+1)*PAD)+in_index];
      }
    }
  }

  if(mesh->neighbours[SOUTH] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < nx; ++jj) {
        const int in_index = dd*nx+jj;
        rho  [dd*nx + jj] = mesh->south_buffer_in[(RHO_OFF*(nx+1)*PAD)+in_index];
        e    [dd*nx + jj] = mesh->south_buffer_in[(E_OFF*(nx+1)*PAD)+in_index];
        rho_v[dd*nx + jj] = mesh->south_buffer_in[(RHO_V_OFF*(nx+1)*PAD)+in_index];
      }
    }

#pragma omp parallel for collapse(2)
    for(int dd = 0; dd < PAD; ++dd) {
      for(int jj = 0; jj < (nx+1); ++jj) {
        const int in_index = dd*(nx+1)+jj;
        rho_u[dd*(nx+1) + jj] = mesh->south_buffer_in[(RHO_U_OFF*(nx+1)*PAD)+in_index];
      }
    }
  }

#if 0
  if(mesh->neighbours[WEST] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int ii = 0; ii < ny; ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int in_index = ii*PAD+dd;
        rho  [ii*nx + dd] = mesh->west_buffer_in[(RHO_OFF*ny*PAD) + in_index];
        e    [ii*nx + dd] = mesh->west_buffer_in[(E_OFF*ny*PAD) + in_index];
        rho_u[ii*(nx+1) + dd] = mesh->west_buffer_in[(RHO_U_OFF*ny*PAD) + in_index];
      }
    }

#pragma omp parallel for collapse(2)
    for(int ii = 0; ii < (ny+1); ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int in_index = ii*PAD+dd;
        rho_v[ii*nx + dd] = mesh->west_buffer_in[(RHO_V_OFF*ny*PAD) + in_index];
      }
    }
  }

  if(mesh->neighbours[EAST] != EDGE) {
#pragma omp parallel for collapse(2)
    for(int ii = 0; ii < ny; ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int in_index = ii*PAD+dd;
        rho  [ii*nx + (nx-PAD+dd)] = mesh->east_buffer_in[(RHO_OFF*ny*PAD)+in_index];
        e    [ii*nx + (nx-PAD+dd)] = mesh->east_buffer_in[(E_OFF*ny*PAD)+in_index];
        rho_u[ii*(nx+1) + ((nx+1)-PAD+dd)] = mesh->east_buffer_in[(RHO_U_OFF*ny*PAD)+in_index];
      }
    }

#pragma omp parallel for collapse(2)
    for(int ii = 0; ii < (ny+1); ++ii) {
      for(int dd = 0; dd < PAD; ++dd) {
        const int in_index = ii*PAD+dd;
        rho_v[ii*nx + (nx-PAD+dd)] = mesh->east_buffer_in[(RHO_V_OFF*ny*PAD)+in_index];
      }
    }
  }
#endif // if 0
}

#endif // if 0

#if 0
#pragma omp parallel for
for(int ii = PAD; ii < (ny+1)-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < (nx+1)-PAD; ++jj) {
    // Calculate the zone edge centered density
    const double rho_edge_x = 
      (rho[ind0]*celldx[jj]*celldy[ii] + rho[ind0-1]*celldx[jj - 1]*celldy[ii]) / 
      (2.0*edgedx[jj]*celldy[ii]);
    const double rho_edge_y = 
      (rho[ind0]*celldy[ii]*celldx[jj] + rho[ind0-nx]*celldy[ii - 1]*celldx[jj]) / 
      (2.0*edgedx[jj]*celldy[ii]);
    u[ind1] = (rho_edge_x == 0.0) ? 0.0 : rho_u[ind1] / rho_edge_x;
    v[ind0] = (rho_edge_y == 0.0) ? 0.0 : rho_v[ind0] / rho_edge_y;
  }
}

handle_boundary(nx+1, ny, mesh, u, INVERT_X, PACK);
handle_boundary(nx, ny+1, mesh, v, INVERT_Y, PACK);
#endif // if 0

#if 0
#pragma omp parallel for
for(int ii = PAD; ii < (ny+1)-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < (nx+1)-PAD; ++jj) {
    // Calculate the maximum and minimum neighbouring density
    const double v_x_max = max(v[ind0-1], max(v[ind0], v[ind0+1]));
    const double v_x_min = min(v[ind0-1], min(v[ind0], v[ind0+1]));
    const double v_y_max = max(v[ind0-nx], max(v[ind0], v[ind0+nx]));
    const double v_y_min = min(v[ind0-nx], min(v[ind0], v[ind0+nx]));

    // Construct absolute value of slope S_L or S_R
    const double s1_x = min(v_x_max - v[ind0], v[ind0] - v_x_min) / (celldx[jj] / 2.0);
    const double s1_y = min(v_y_max - v[ind0], v[ind0] - v_y_min) / (celldy[ii] / 2.0);

    // Calculate the density interpolated from the zone center to zone boundary
    const double v_edge_l = 
      (celldx[jj]*v[ind0 - 1] + celldx[jj - 1]*v[ind0])/(celldx[jj] + celldx[jj - 1]);
    const double v_edge_r = 
      (celldx[jj + 1]*v[ind0] + celldx[jj]*v[ind0 + 1])/(celldx[jj + 1] + celldx[jj]);
    const double v_edge_d = 
      (celldy[ii]*v[ind0 - nx] + celldy[ii - 1]*v[ind0])/(celldy[ii] + celldy[ii - 1]);
    const double v_edge_u = 
      (celldy[ii + 1]*v[ind0] + celldy[ii]*v[ind0 + nx])/(celldy[ii + 1] + celldy[ii]);

    // Construct the slope
    const double s2_x = (v_edge_r - v_edge_l) / celldx[jj];
    const double s2_y = (v_edge_u - v_edge_d) / celldy[ii];

    // Define the zone centered slope (culling 0's)
    slope_x[ind1] = (s2_x != 0.0) ? (s2_x / fabs(s2_x))*min(fabs(s2_x), s1_x) : 0.0;
    slope_y[ind0] = (s2_y != 0.0) ? (s2_y / fabs(s2_y))*min(fabs(s2_y), s1_y) : 0.0;
  }
}
#endif // if 0


#if 0
#pragma omp parallel for
for(int ii = PAD; ii < (ny+1)-PAD; ++ii) {
#pragma omp simd
  for(int jj = PAD; jj < (nx+1)-PAD; ++jj) {
    const double u_x_max = max(u[ind1-1], max(u[ind1], u[ind1+1]));
    const double u_x_min = min(u[ind1-1], min(u[ind1], u[ind1+1]));
    const double u_y_max = max(u[ind1-(nx+1)], max(u[ind1], u[ind1+(nx+1)]));
    const double u_y_min = min(u[ind1-(nx+1)], min(u[ind1], u[ind1+(nx+1)]));

    // Construct absolute value of slope S_L or S_R
    const double s1_x = min(u_x_max - u[ind1], u[ind1] - u_x_min) / (celldx[jj] / 2.0);
    const double s1_y = min(u_y_max - u[ind1], u[ind1] - u_y_min) / (celldy[ii] / 2.0);

    const double u_edge_l = 
      (edgedx[jj]*u[ind1-1] + edgedx[jj-1]*u[ind1])/(edgedx[jj] + edgedx[jj - 1]);
    const double u_edge_r = 
      (edgedx[jj+1]*u[ind1] + edgedx[jj]*u[ind1+1])/(edgedx[jj+1] + edgedx[jj]);
    const double u_edge_d = 
      (edgedy[ii]*u[ind1 - (nx+1)] + edgedy[ii - 1]*u[ind1])/(edgedy[ii] + edgedy[ii - 1]);
    const double u_edge_u = 
      (edgedy[ii + 1]*u[ind1] + edgedy[ii]*u[ind1 + (nx+1)])/(edgedy[ii + 1] + edgedy[ii]);

    // Construct the slope
    const double s2_x = (u_edge_r - u_edge_l) / edgedx[jj];
    const double s2_y = (u_edge_u - u_edge_d) / edgedy[ii];

    // Define the zone centered slope (culling 0's)
    slope_x[ind1] = (s2_x != 0.0) ? (s2_x / fabs(s2_x))*min(fabs(s2_x), s1_x) : 0.0;
    slope_y[ind0] = (s2_y != 0.0) ? (s2_y / fabs(s2_y))*min(fabs(s2_y), s1_y) : 0.0;
  }
}
#endif // if 0
